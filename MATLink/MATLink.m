(* :Title: MATLink *)
(* :Context: MATLink` *)
(* :Authors:
	R. Menon (rsmenon@icloud.com)
	Sz. Horvát (szhorvat@gmail.com)
*)
(* :Package Version: 0.1 *)
(* :Mathematica Version: 9.0 *)

BeginPackage["MATLink`"]

ConnectMATLAB::usage =
	"ConnectMATLAB[] establishes a connection with the MATLink engine, but does not open an instance of MATLAB."

DisconnectMATLAB::usage =
	"DisconnectMATLAB[] closes an existing connection with the MATLink engine."

OpenMATLAB::usage =
	"OpenMATLAB[] opens an instance of MATLAB and allows you to access its workspace."

CloseMATLAB::usage =
	"CloseMATLAB[] closes a previously opened instance of MATLAB (opened via MATLink)."

ShowMATLAB::usage =
	"Show the MATLAB command window."

HideMATLAB::usage =
	"Hide the MATLAB command window."

MGet::usage =
	"MGet[var] imports the MATLAB variable named \"var\" into Mathematica. MGet is Listable."

MSet::usage =
	"MSet[var, expr] exports the value in expr and saves it in a variable named \"var\" in MATLAB's workspace."

MEvaluate::usage =
	"MEvaluate[expr] evaluates a valid MATLAB expression (entered as a string) and displays an error otherwise."

MScript::usage =
	"MScript[filename, expr] creates a MATLAB script named \"filename\" with the contents in expr (string) and stores it on MATLAB's path, but does not evaluate it. These files will be removed when the MATLink engine is closed."

MFunction::usage =
	"MFunction[func] creates a link to a MATLAB function for use from Mathematica."

MATLink::usage =
	"MATLink refers to the MATLink package. Set cross-session package options to this symbol."

MATLink::visnowin = "Showing or hiding the MATLAB command window is only supported on Windows."

mcell::usage = "" (* TODO Make this private before release *)

Begin["`Developer`"]

(*Directories & file paths*)
$ApplicationDirectory = DirectoryName@$InputFileName;
$ApplicationDataDirectory = FileNameJoin[{$UserBaseDirectory, "ApplicationData", "MATLink"}];
$EngineSourceDirectory = FileNameJoin[{$ApplicationDirectory, "Engine", "src"}];
$BinaryDirectory = FileNameJoin[{$ApplicationDirectory, "Engine", "bin", $OperatingSystem <> IntegerString[$SystemWordLength]}];
$BinaryPath = FileNameJoin[{$BinaryDirectory, If[$OperatingSystem === "Windows", "mengine.exe", "mengine"]}];

(*Log files and related functions *)
If[!DirectoryQ@$ApplicationDataDirectory, CreateDirectory@$ApplicationDataDirectory];

$logfile = FileNameJoin[{$ApplicationDataDirectory, "MATLink.log"}]

(*Log message types:
	matlink – Standard MATLink` action
	info    – System info
	user    – User initiated action
	warning – MATLink` warning
	error   – MATLink` error
	fatal   – Fatal error; cannot recover *)
writeLog[message_, type_:"matlink"] :=
	Module[{str = OpenAppend[$logfile], date = DateString[]},
		WriteString[str, StringJoin @@ Riffle[{date, type, message, "\n"}, "\t"]];
		Close[str];
	]

clearLog[] := Module[{str = OpenWrite[$logfile]}, Close@str;]

ShowLog[] := FilePrint@$logfile

SetAttributes[message, HoldFirst]
message[m_MessageName, args___][type_] :=
	Module[{},
		writeLog[ToString@StringForm[m, args], type];
		Message[m, args];
	]

(*Settings file*)
$SettingsFile = FileNameJoin[{$ApplicationDataDirectory, "init.m"}];

MATLink /: SetOptions[MATLink, opts_] :=
	With[{currOpts = Options@MATLink, str = OpenWrite@$SettingsFile},
		WriteString[str, "(* This file is automatically generated by MATLink. Do not edit this file or modify its contents.\nUse SetOptions[MATLink, {option -> value}] to modify the default options. *)\n"];
		Write[str,
			Options@MATLink = Sort@DeleteDuplicates[# ~Join~ currOpts &@ FilterRules[opts, currOpts], First@# == First@#2&]
		];
		Close@str;
		writeLog["MATLink settings changed: " <> ToString@Options@MATLink, "user"];
	]

Options@MATLink = {"DefaultMATLABDirectory" -> "/Applications/MATLAB_R2012b.app/", "ReturnLogicalsAs0And1" -> False};
If[FileExistsQ@$SettingsFile,
	Options@MATLink = Get@$SettingsFile;,

	writeLog["Missing init.m; Creating a new file.", "matlink"];
	SetOptions[MATLink, Options@MATLink];
]

$DefaultMATLABDirectory := OptionValue[MATLink, "DefaultMATLABDirectory"];
$ReturnLogicalsAs0And1 := OptionValue[MATLink, "ReturnLogicalsAs0And1"];

(*Other Developer` functions*)
CompileMEngine::unsupp := "Automatically compiling the MATLink Engine from source is not supported on ``. Please compile it manually."
CompileMEngine::failed := "Automatically compiling the MATLink Engine has failed. Please try to compile it manually and ensure that the path to the MATLAB directory is set correctly in the makefile."

(* CompileMEngine[] will Abort[] on failure to avoid an infinite loop. *)
CompileMEngine[] :=
	Module[{},
		writeLog["Compiled MATLink Engine on " <> $OperatingSystem, "user"];
		CompileMEngine[$OperatingSystem]
	]

CompileMEngine["MacOSX"] :=
	Block[{dir = Directory[]},
		SetDirectory[$EngineSourceDirectory];
		PrintTemporary["Compiling the MATLink Engine from source...\n"];
		If[ Run["make -f Makefile.osx"] != 0,
			SetDirectory[dir];
			message[CompileMEngine::failed]["error"];
			Abort[];
		];
		Run["mv mengine " <> $BinaryPath];
		Run["make -f Makefile.osx clean"];
		SetDirectory[dir]
	]

CompileMEngine["Unix"] :=
	If[$SystemWordLength == 64,
		Block[{dir = Directory[]},
			SetDirectory[$EngineSourceDirectory];
			PrintTemporary["Compiling the MATLink Engine from source...\n"];
			If[ Run["make -f Makefile.lin64"] != 0,
				SetDirectory[dir];
				message[CompileMEngine::failed]["error"];
				Abort[];
			];
			Run["mv mengine " <> $BinaryPath];
			Run["make -f Makefile.lin64 clean"];
			SetDirectory[dir]
		],

		message[CompileMEngine::unsupp, "non-64-bit Linux"]["error"]; Abort[]
	]

CompileMEngine[os_] := (message[CompileMEngine::unsupp, os]["error"]; Abort[])

CleanupTemporaryDirectories[] :=
	Module[{dirs = FileNames@FileNameJoin[{$TemporaryDirectory,"MATLink*"}]},
		writeLog[ToString@StringForm["Removed `` temporary directories", Length@dirs]];
		DeleteDirectory[#, DeleteContents -> True] & /@ dirs;
	]

End[] (* `Developer` *)

Begin["`Private`"]
AppendTo[$ContextPath, "MATLink`Developer`"];

(* Common error messages *)
MATLink::needs = "MATLink is already loaded. Remember to use Needs instead of Get.";
General::wspo = "The MATLAB workspace is already open."
General::wspc = "The MATLAB workspace is already closed."
General::engo = "There is an existing connection to the MATLAB engine."
General::engc = "Not connected to the MATLAB engine."
General::nofn = "The `1` \"`2`\" does not exist."
General::owrt = "An `1` by that name already exists. Use \"Overwrite\" \\[Rule] True to overwrite."
General::badval = "Invalid option value `1` passed to `2`. Values must match the pattern `3`"

(* Directories and helper functions/variables *)
EngineBinaryExistsQ[] := FileExistsQ[$BinaryPath];

(* Set these variables only once per session.
This is to avoid losing connection/changing temporary directory because the user used Get instead of Needs *)
If[!TrueQ[MATLinkLoadedQ[]],
	MATLinkLoadedQ[] = True;
	MATLABInstalledQ[] = False;
	$openLink = {};
	$sessionID = "";
	$temporaryVariablePrefix = "";
	$sessionTemporaryDirectory = "";
	writeLog["Loaded MATLink`", "user"];
	writeLog["Version: " <> $Version, "info"];
	writeLog["OS: " <> $OperatingSystem, "info"];
	writeLog["MATLAB: " <> $DefaultMATLABDirectory, "info"];
	writeLog["MATLink: " <> ToString@Options@MATLink, "info"];,

	message[MATLink::needs]["warning"]
]

EngineLinkQ[LinkObject[link_String, _, _]] := ! StringFreeQ[link, "mengine.sh"];

(* To close previously opened links that were not terminated properly (possibly from a crash) *)
cleanupOldLinks[] :=
	Module[{links = Select[Links[], EngineLinkQ]},
		writeLog[ToString@StringForm["Closed `` old link objects.", Length@links]];
		LinkClose /@ links;
		MATLABInstalledQ[] = False;
	]

MScriptQ[name_String] /; MATLABInstalledQ[] :=
	FileExistsQ[FileNameJoin[{$sessionTemporaryDirectory, name <> ".m"}]]

randomString[n_Integer:50] :=
	StringJoin@RandomSample[Join[#, ToLowerCase@#] &@CharacterRange["A", "Z"], n]

(* Check MATLAB code for syntax errors before evaluating.
This is necessary because a bug in the engine causes it to hang if there is a syntax error. *)
errorsInMATLABCode[cmd_String] :=
	Module[
		{
			file = MScript[randomString[], cmd],
			config = FileNameJoin[{$ApplicationDirectory, "Kernel", "MLintErrors.txt"}],
			result
		},
		eval@ToString@StringForm[
			"`1` = checkcode('`2`','-id','-config=`3`')",
			First@file, file["AbsolutePath"],config
		];
		result = List@@MGet@First@file;
		eval@ToString@StringForm["clear `1`", First@file];
		DeleteFile@file["AbsolutePath"];
		If[result =!= {}, "message" /. Flatten@result, None]
	]

validOptionsQ[func_Symbol, opts_] :=
	With[{o = FilterRules[opts, Options[func]], patt = validOptionPatterns[func]},
		If[o =!= opts,
			Message[func::optx, First@FilterRules[opts, Except[Options@func]], func]; False,
			FreeQ[If[MatchQ[#2, #1], True, Message[func::badval, #2, func, #1];False] & @@@ (opts /. patt), False]
		]
	]

(* Connect/Disconnect MATLAB engine *)
ConnectMATLAB[] /; EngineBinaryExistsQ[] && !MATLABInstalledQ[] :=
	Module[{},
		cleanupOldLinks[];
		$openLink = Install@FileNameJoin[{$BinaryDirectory, If[$OperatingSystem === "Windows", "mengine.exe", "mengine.sh"]}];
		$sessionID = StringJoin[
			 IntegerString[{Most@DateList[]}, 10, 2],
			 IntegerString[List @@ Rest@$openLink]
		];
		$temporaryVariablePrefix = "MATLink" <> $sessionID;
		$sessionTemporaryDirectory = FileNameJoin[{$TemporaryDirectory, "MATLink" <> $sessionID}];
		CreateDirectory@$sessionTemporaryDirectory;
		MATLABInstalledQ[] = True;
		writeLog["Connected to the MATLink Engine"];
	]

ConnectMATLAB[] /; EngineBinaryExistsQ[] && MATLABInstalledQ[] := message[ConnectMATLAB::engo]["warning"]

ConnectMATLAB[] /; !EngineBinaryExistsQ[] :=
	Module[{},
		writeLog["Compiled MATLink Engine on " <> $OperatingSystem, "matlink"];
		CompileMEngine[$OperatingSystem];
		ConnectMATLAB[];
	]

DisconnectMATLAB[] /; MATLABInstalledQ[] :=
	Module[{},
		LinkClose@$openLink;
		$openLink = {};
		DeleteDirectory[$sessionTemporaryDirectory, DeleteContents -> True];
		MATLABInstalledQ[] = False;
		writeLog["Disconnected from the MATLink Engine"];
	]

DisconnectMATLAB[] /; !MATLABInstalledQ[] := message[DisconnectMATLAB::engc]["warning"]

(* Open/Close MATLAB Workspace *)
OpenMATLAB[] /; MATLABInstalledQ[] :=
	Module[{},
		writeLog["Opened MATLAB workspace"];
		openEngine[]
	] /; !engineOpenQ[];

OpenMATLAB[] /; MATLABInstalledQ[] := message[OpenMATLAB::wspo]["warning"] /; engineOpenQ[];

OpenMATLAB[] /; !MATLABInstalledQ[] :=
	Module[{},
		ConnectMATLAB[];
		OpenMATLAB[];
		MEvaluate["addpath('" <> $sessionTemporaryDirectory <> "')"];
	]

CloseMATLAB[] /; MATLABInstalledQ[] :=
	Module[{},
		writeLog["Closed MATLAB workspace"];
		closeEngine[]
	] /; engineOpenQ[] ;

CloseMATLAB[] /; MATLABInstalledQ[] := message[CloseMATLAB::wspc]["warning"] /; !engineOpenQ[];
CloseMATLAB[] /; !MATLABInstalledQ[] := message[CloseMATLAB::engc]["warning"];

(* Show or hide MATLAB on Windows *)

ShowMATLAB[] := (If[$OperatingSystem =!= "Windows", Message[MATLink::visnowin]]; setVisible[1])
HideMATLAB[] := (If[$OperatingSystem =!= "Windows", Message[MATLink::visnowin]]; setVisible[0])


(* MGet & MSet *)
MGet::unimpl = "Translating the MATLAB type \"`1`\" is not supported"

SyntaxInformation[MGet] = {"ArgumentsPattern" -> {_}};
SetAttributes[MGet,Listable]

MGet[var_String] /; MATLABInstalledQ[] :=
	convertToMathematica@get[var] /; engineOpenQ[]

MGet[_String] /; MATLABInstalledQ[] := message[MGet::wspc]["warning"] /; !engineOpenQ[]
MGet[_String] /; !MATLABInstalledQ[] := message[MGet::engc]["warning"]

MSet::sparse = "Only one and two dimensional sparse arrays are supported; the default element must be 0 for numerical and False for boolean arrays."
MSet::dupfield = "Duplicate field names not alowed in struct."

SyntaxInformation[MSet] = {"ArgumentsPattern" -> {_, _}};

MSet[var_String, expr_] /; MATLABInstalledQ[] :=
	Internal`WithLocalSettings[
		Null,
		mset[var, convertToMATLAB[expr]],
		cleanHandles[]	(* prevent memory leaks *)
	] /; engineOpenQ[]

MSet[___] /; MATLABInstalledQ[] := message[MSet::wspc]["warning"] /; !engineOpenQ[]
MSet[___] /; !MATLABInstalledQ[] := message[MSet::engc]["warning"]

(* MEvaluate *)
MEvaluate::errx = "``" (* Fill in when necessary with the error that MATLAB reports *)

SyntaxInformation[MEvaluate] = {"ArgumentsPattern" -> {_}};

MEvaluate[cmd_String] /; MATLABInstalledQ[] :=
	Catch[
		Module[{result, error, id = randomString[]},
			If[
				TrueQ[(error = errorsInMATLABCode@cmd) === None],
				result = eval@StringJoin["
					try
						", cmd, "
					catch ex
						sprintf('%s%s%s', '", id, "', ex.getReport,'", id, "')
					end
				"],
				Message[MEvaluate::errx, error];Throw[$Failed, $error]
			];
			If[StringFreeQ[result,id],
				StringReplace[result, StartOfString~~">> " -> ""],
				First@StringCases[result, __ ~~ id ~~ x__ ~~ id ~~ ___ :> (Message[MEvaluate::errx, x];Throw[$Failed, $error])]
			]
		],
		$error
	] /; engineOpenQ[]

MEvaluate[MScript[name_String]] /; MATLABInstalledQ[] && MScriptQ[name] :=
	eval[name] /; engineOpenQ[]

MEvaluate[MScript[name_String]] /; MATLABInstalledQ[] && !MScriptQ[name] :=
	message[MEvaluate::nofn,"MScript", name]["error"]

MEvaluate[___] /; MATLABInstalledQ[] := message[MEvaluate::wspc]["warning"] /; !engineOpenQ[]
MEvaluate[___] /; !MATLABInstalledQ[] := message[MEvaluate::engc]["warning"]

(* MScript & MFunction *)
Options[MScript] = {"Overwrite" -> False};
validOptionPatterns[MScript] = {"Overwrite" -> True | False};

MScript[name_String, cmd_String, opts : OptionsPattern[]] /; MATLABInstalledQ[] :=
	Module[{file},
		file = OpenWrite[FileNameJoin[{$sessionTemporaryDirectory, name <> ".m"}], CharacterEncoding -> "UTF-8"];
		WriteString[file, cmd];
		Close[file];
		MScript[name]
	] /; (!MScriptQ[name] || OptionValue["Overwrite"]) && validOptionsQ[MScript, {opts}]

MScript[name_String, cmd_String, opts : OptionsPattern[]] /; MATLABInstalledQ[] :=
	message[MScript::owrt, "MScript"]["warning"] /; MScriptQ[name] && !OptionValue["Overwrite"] && validOptionsQ[MScript, {opts}]

MScript[name_String, cmd_String, OptionsPattern[]] /; !MATLABInstalledQ[] := message[MScript::engc]["warning"]

MScript[name_String]["AbsolutePath"] /; MScriptQ[name] :=
	FileNameJoin[{$sessionTemporaryDirectory, name <> ".m"}]

Options[MFunction] = {"Output" -> True, "OutputArguments" -> 1};
validOptionPatterns[MFunction] = {"Output" -> True | False, "OutputArguments" -> _Integer?Positive | 0};
(* Since MATLAB allows arbitrary function definitions depending on the number of output arguments, we force the user to explicitly specify the number of outputs if it is different from the default value of 1. *)

MFunction[name_String, opts : OptionsPattern[]][args___] /; MATLABInstalledQ[] :=
	Module[{nIn = Length[{args}], nOut = OptionValue["OutputArguments"], vars, output},
		vars = Table[ToString@Unique[$temporaryVariablePrefix], {nIn + nOut}];
		Thread[MSet[vars[[;;nIn]], {args}]];
		MEvaluate[StringJoin["[", Riffle[vars[[-nOut;;]], ","], "]=", name, "(", Riffle[vars[[;;nIn]], ","], ")"]];
		output = MGet /@ vars[[-nOut;;]];
		MEvaluate[StringJoin["clear ", Riffle[vars, " "]]];
		If[nOut == 1, First@output, output]
	] /; OptionValue["Output"] && validOptionsQ[MFunction, {opts}]

MFunction[name_String, opts : OptionsPattern[]][args___] /; MATLABInstalledQ[] :=
	With[{vars = Table[ToString@Unique[$temporaryVariablePrefix], {Length[{args}]}]},
		Thread[MSet[vars, {args}]];
		MEvaluate[StringJoin[name, "(", Riffle[vars, ","], ")"]];
		MEvaluate[StringJoin["clear ", Riffle[vars, " "]]];
	] /; !OptionValue["Output"] && validOptionsQ[MFunction, {opts}]

MFunction[name_String, OptionsPattern[]][args___] /; MATLABInstalledQ[] := message[MFunction::wspc]["warning"] /; !engineOpenQ[]
MFunction[name_String, OptionsPattern[]][args___] /; !MATLABInstalledQ[] := message[MFunction::engc]["warning"]

mcell[] :=
	Module[{},
		CellPrint@Cell[
			TextData[""],
			"Program",
			Evaluatable->True,
			CellEvaluationFunction -> (MEvaluate@First@FrontEndExecute[FrontEnd`ExportPacket[Cell[#], "InputText"]] &), (* TODO figure out how to avoid conversion to \[AAcute], \[UDoubleAcute], etc. forms *)
			CellGroupingRules -> "InputGrouping",
			CellFrameLabels -> {{None,"MATLAB"},{None,None}}
		];
		SelectionMove[EvaluationNotebook[], All, EvaluationCell];
		NotebookDelete[];
		SelectionMove[EvaluationNotebook[], Next, CellContents]
	]

End[] (* MATLink`Private` *)

(* Low level functions strongly tied with the C++ code are part of this context *)
Begin["`Engine`"]
AppendTo[$ContextPath, "MATLink`Private`"]

(* Assign to symbols defined in `Private` *)
engineOpenQ[] /; MATLABInstalledQ[] := engOpenQ[]
engineOpenQ[] /; !MATLABInstalledQ[] := False
openEngine = engOpen;
closeEngine = engClose;
eval = engEvaluate;
get = engGet;
set = engSet;
cleanHandles = engCleanHandles;
setVisible = engSetVisible;

(* CONVERT DATA TYPES TO MATHEMATICA *)

(* The following mat* heads are inert and indicate the type of the MATLAB data returned
   by the engine. They must be part of the MATLink`Engine` context.
   Evaluation is only allowed inside the convertToMathematica function,
   which converts it to their final Mathematica form. engGet[] will always return
   either $Failed, or an expression wrapped in one of the below heads.
   Note that structs and cells may contain subexpressions of other types.
*)

convertToMathematica[expr_] :=
	With[
		{
			reshape = Switch[#2,
				{_,1}, #[[All, 1]],
				_, Transpose[#, Reverse@Range@ArrayDepth@#]
			]&,
			listToArray = First@Fold[Partition, #, Reverse[#2]]&
		},
		Block[{matCell,matArray,matStruct,matSparseArray,matLogical,matString,matUnknown},

			matCell[list_, {1,1}] := list[[1]];
			matCell[list_, dim_] := listToArray[list,dim] ~reshape~ dim;

			matStruct[list_, {1,1}] := list[[1]];
			matStruct[list_, dim_] := listToArray[list,dim] ~reshape~ dim;

			matSparseArray[jc_, ir_, vals_, dims_] := Transpose@SparseArray[Automatic, dims, 0, {1, {jc, List /@ ir + 1}, vals}];

			matSparseLogical[jc_, ir_, vals_, dims_] :=
				If[ $ReturnLogicalsAs0And1,
					Transpose@SparseArray[Automatic, dims, 0, {1, {jc, List /@ ir + 1}, vals}],
					Transpose@SparseArray[Automatic, dims, False, {1, {jc, List /@ ir + 1}, vals /. 1 -> True}]
				];

			matLogical[list_, {1,1}] := matLogical@list[[1,1]];
			matLogical[list_, dim_] := matLogical[list ~reshape~ dim];
			matLogical[list_] /; $ReturnLogicalsAs0And1 := list;
			matLogical[list_] /; !$ReturnLogicalsAs0And1 := list /. {1 -> True, 0 -> False};

			matArray[list_, {1,1}] := list[[1,1]];
			matArray[list_, dim_] := list ~reshape~ dim;

			matString[str_] := str;

			matUnknown[u_] := (message[MGet::unimpl, u]["error"]; $Failed);

			expr
		]
	]

(* CONVERT DATA TYPES TO MATLAB *)

complexArrayQ[arr_] := Developer`PackedArrayQ[arr, Complex] || (Not@Developer`PackedArrayQ[arr] && Not@FreeQ[arr, Complex])

booleanQ[True | False] = True
booleanQ[_] = False

ruleQ[_Rule] = True
ruleQ[_] = False

handleQ[_handle] = True
handleQ[_] = False

structHandleQ[_String -> _handle] = True
structHandleQ[_] = False

(* the convertToMATLAB function will always end up with a handle[] if it was successful *)
mset[name_String, handle[h_Integer]] := engSet[name, h]
mset[name_, _] := $Failed

convertToMATLAB[expr_] :=
	Module[{structured,reshape = Composition[Flatten, Transpose[#, Reverse@Range@ArrayDepth@#]&]},
		structured = restructure[expr];

		Block[{MArray, MSparseArray, MLogical, MSparseLogical, MString, MCell, MStruct},
			MArray[vec_?VectorQ] := MArray[{vec}];
			MArray[arr_] :=
				With[{list = reshape@Developer`ToPackedArray@N[arr]},
					If[ complexArrayQ[list],
						engMakeComplexArray[Re[list], Im[list], Reverse@Dimensions[arr]],
						engMakeRealArray[list, Reverse@Dimensions[arr]]
					]
				];

			MString[str_String] := engMakeString[str];

			(* TODO allow casting array of 0s and 1s to logical *)
			MLogical[arr_] := engMakeLogical[Boole@reshape@arr, Reverse@Dimensions@arr];

			MCell[vec_?VectorQ] := MCell[{vec}];
			MCell[arr_?(ArrayQ[#, _, handleQ]&)] :=
				engMakeCell[reshape@arr /. handle -> Identity, Reverse@Dimensions[arr]];

			(* http://mathematica.stackexchange.com/questions/18081/how-to-interpret-the-fullform-of-a-sparsearray *)
			MSparseArray[HoldPattern@SparseArray[Automatic, {n_, m_}, 0, {1, {jc_, ir_}, values_}]] :=
				If[ complexArrayQ[values],
					engMakeSparseComplex[Flatten[ir]-1, jc, Re[values], Im[values], m, n],
					engMakeSparseReal[Flatten[ir]-1, jc, values, m, n]
				];
			MSparseArray[_] := (message[MSet::sparse]["error"]; $Failed);

			MSparseLogical[HoldPattern@SparseArray[Automatic, {n_, m_}, False, {1, {jc_, ir_}, values_}]] :=
				engMakeSparseLogical[Flatten[ir]-1, jc, Boole[values], m, n];

			MStruct[rules_] :=
				If[ !ArrayQ[rules, _, structHandleQ],
					$Failed,
					engMakeStruct[rules[[All,1]], rules[[All, 2, 1]]]
				];

			structured (* $Failed falls through *)
		]
	]

restructure[expr_] := Catch[dispatcher[expr], $dispTag]

dispatcher[expr_] :=
	Switch[
		expr,

		(* packed arrays are always numeric *)
		_?Developer`PackedArrayQ,
		MArray[expr],

		(* catch sparse arrays early *)
		_SparseArray,
		handleSparse[expr],

		(* empty *)
		Null | {},
		MArray[{}],

		(* scalar *)
		_?NumericQ,
		MArray[{expr}],

		(* non-packed numerical array *)
		_?(ArrayQ[#, _, NumericQ] &),
		MArray[expr],

		(* logical scalar *)
		True | False,
		MLogical[{expr}],

		(* logical array *)
		_?(ArrayQ[#, _, booleanQ] &),
		MLogical[expr],

		(* string *)
		_String,
		MString[expr],

		(* string array *)
		(* _?(ArrayQ[#, _, StringQ] &),
		MString[expr], *)

		(* struct -- may need recursion *)
		(*MStruct[_],
		MStruct[handleStruct@First[expr]],*)

		(* struct *)
		_?(VectorQ[#, ruleQ] &),
		MStruct[handleStruct[expr]],

		(* cell -- may need recursion *)
		MCell[_],
		MCell[handleCell@First[expr]],

		(* cell *)
		_List,
		MCell[handleCell[expr]],

		(* assumed already handled, no recursion needed; only MCell and MStruct may need recursion *)
		_MArray | _MLogical | _MSparseArray | _MSparseLogical | _MString,
		expr,

		_,
		Throw[$Failed, $dispTag]
	]

handleSparse[arr_SparseArray ? (VectorQ[#, NumericQ]&) ] := MSparseArray[Transpose@SparseArray[{arr}]] (* convert to matrix *)
handleSparse[arr_SparseArray ? (MatrixQ[#, NumericQ]&) ] := MSparseArray[Transpose@SparseArray[arr]] (* the extra SparseArray call gets rid of background elements *)
handleSparse[arr_SparseArray ? (VectorQ[#, booleanQ]&) ] := MSparseLogical[Transpose@SparseArray[{arr}]]
handleSparse[arr_SparseArray ? (MatrixQ[#, booleanQ]&) ] := MSparseLogical[Transpose@SparseArray[arr]]
handleSparse[_] := (message[MSet::sparr]["error"]; Throw[$Failed, $dispTag]) (* higher dim sparse arrays or non-numerical ones are not supported *)

handleStruct[rules_ ? (VectorQ[#, ruleQ]&)] :=
	If[ Length@Union[rules[[All,1]]] != Length[rules],
		message[MSet::dupfield]["error"]; $Failed,
		Thread[rules[[All, 1]] -> dispatcher /@ rules[[All, 2]]]
	]

handleStruct[_] := $Failed (* TODO multi-element struct *)

handleCell[list_List] := dispatcher /@ list
handleCell[expr_] := dispatcher[expr]

End[] (* MATLink`Engine` *)

EndPackage[] (* MATLink` *)
